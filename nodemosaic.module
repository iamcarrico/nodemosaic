<?php
/**
 * Implements hook_help.
 *
 * Displays help and module information.
 *
 * @param path 
 *   Which path of the site we're using to display help
 * @param arg 
 *   Array that holds the current path as returned from arg() function
 */
function nodemosaic_help($path, $arg) {
	switch ($path) {
		case "admin/help#nodemosiac":
			return '<p>'.  t("Displays node tiles in a grid, handles certain field rules") .'</p>';
			break;
	}
}

/**
 * Implements hook_block_info().
 */
function nodemosaic_block_info() {
  $blocks['nodemosaic_block'] = array(
    'info' => t('Mosaic Display'), //The name that will appear in the block list.
    'cache' => DRUPAL_CACHE_PER_ROLE, //Default
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function nodemosaic_block_view($delta = '') {
	switch($delta){
		case 'nodemosaic_block':
			$block['subject'] = t('Mosaic Display');
			if(user_access('access content')){
				$block['content'] = '<div id="nodemosaic-viewport"><div id="nodemosaic-wall"></div></div>';
			}
			break;
	}
	return $block;
}

function nodemosaic_init() {
	/* We need jQuery.ui Draggable for the mosaic tile. */
	drupal_add_library('system', 'ui.draggable');
}

function nodemosaic_menu() {
	$items['nodemosaic/tile'] = array(
		'title' => 'Node Mosaic Tile by JSON',
		'page callback' => 'nodemosaic_tile_view',
		'access callback' => true, /* All visitors have access */ 
		'type' => MENU_CALLBACK,
	);
	return $items;
}

function nodemosaic_tile_view($col = false, $row = false) {
	if ( $col > 0 && $row > 0 ) {
		$cache = cache_get(('tile_' . $col . 'x' . $row), "cache_nodemosaic");
		if ( $cache ) {
			// We got a cached object\
			if ($cache->expire > REQUEST_TIME || $cache->expire == 0) {
				// It's either current or permanent; use it.
				drupal_json_output($cache->data);
				exit;
			} else {
				// Past expiration; moving on.
			}
		}
		
		$query = new EntityFieldQuery();
		$query
		  ->entityCondition('entity_type', 'node', '=')
		  ->propertyCondition('status', 1, '=')
		  ->fieldCondition('field_tilecol', 'value', $col, '=')
		  ->fieldCondition('field_tilerow', 'value', $row, '=')
		  ->addMetaData('account', user_load(1));
			/* DANGER, WILL ROBINSON: This allows the lookup query to run as if
			   user #1 was running it, bypassing any node_access rules (like those
			   set up by Workflow Access). Without this, the query results are
			   empty for tiles awaiting moderation, which triggers the javascript
			   front-end to put an "Add" link there. We'll make sure, when the
			   JSON is dispatched, to return a string error code instead of the
			   node object to maintain the need for moderation. */

		$result = $query->execute();
		$data = false; /* To store output. */
		$expiration = time() + (60 * 5); /* Expiration time. 5 min default. */
		
		if (isset($result['node'])) {
			$node = array_shift(entity_load('node', array_keys($result['node'])));
			$output = array(
				'nid' => $node->nid,
				'title' => $node->title,
				'path' => '/' . drupal_lookup_path('alias',"node/".$node->nid),
				'image' => image_style_url('nodemosaic_tile', $node->field_tileimage['und'][0]['uri']),
				'workflow' => $node->workflow,
					/* Tentatively 1=Creation, 2=Awaiting Moderation, 3=Approved */
			);
			if ($output['workflow'] === "3") {
				// It's the third workflow state, "approved." Send it.
				$data = $output;
				// Also, it ain't likely to change. Let's keep it "forever"
				$expiration = CACHE_PERMANENT;
			} else {
				$data = 'pending';
				$expiration = time() + (60 * 60);
					/* It's gonna be moderated soon but it doesn't *have* to
					   show up immediately. Set for 1 hour. */
			}
		}
		else {
			$data = 'no_result';
			$expiration = time() + (60 * 5);
				/* It hasn't been claimed yet, but if it gets claimed before this
				   has expired, someone's gonna get a bizarre error they may not
				   know how to fix. Don't keep this too long. Set for 5 minutes. */
		}
		
		drupal_json_output($data);
		cache_set(('tile_' . $col . 'x' . $row), $data, "cache_nodemosaic", $expiration);
	} else {
		drupal_json_output('range_error');
	}
	exit;
}

function nodemosaic_field_access($op, $field, $entity_type, $entity, $account) {
	/* When a tile is created, the row and column should be editable; once the
	tile has been created, they should not change. Here, we identify those fields
	and return empty($entity->nid) for access to those fields. That function would
	return true for a new node (the node doesn't exist so NID would be empty) and
	returns false for an existing node (when these values should not be allowed
	to change). */
	if ($op == 'edit' && $field['field_name'] == 'field_tilecol') { return empty($entity->nid); }
	if ($op == 'edit' && $field['field_name'] == 'field_tilerow') { return empty($entity->nid); }
}

/**
 * Implements hook_field_formatter_info().
 *
 * We need to set up a field formatter for field_tilerow & field_tilecol to let
 * those fields be placed on the page for JavaScript to find and use to recenter
 * the mosaic.
 */
function nodemosaic_field_formatter_info() {
	return array(
		'nodemosaic_colrow_display' => array(
			'label' => t('Node Mosaic Coordinate Field'),
			'field types' => array('number_integer'),
		),
	);
}
 
/**
 * Implements hook_field_formatter_view(). This code just passes straight
 * through to a theme function, MYMODULE_formatter_FORMATTER
 * (e.g. MYMODULE_formatter_MYMODULE_absolute_url).
 */
function nodemosaic_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
	$elements = array();
	foreach ($items as $delta => $item) {
		$elements[$delta]['#markup'] = '<span class="nodemosaic_coords" id="' . $field['field_name'] . '">' . $item['value'] .'</span>';
	}
	return $elements;
}
